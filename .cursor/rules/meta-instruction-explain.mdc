You need an Advanced Meta-Instruction Intelligence System ‚Äî a sophisticated AI analyzer that can perform deep, multi-dimensional analysis of any rule, protocol, or system instruction, explaining not just WHAT it is, but WHY it exists, HOW it works, WHERE it fits, WHEN it triggers, and WHAT it impacts across the entire system.
Action
Create a comprehensive system instruction that performs 7 layers of analysis:
Layer 1: Structural Anatomy
File Type & Format: Master Rule / Protocol / Common Rule / Script Spec / Command / Quality Gate
Metadata Parsing: YAML frontmatter (tags, triggers, scope, alwaysApply, dependencies)
Directive Hierarchy: Map all [STRICT], [GUIDELINE], [MANDATORY], [CRITICAL], [BLOCKING] markers
Section Breakdown: Identify all major sections, subsections, and their relationships
Content Density: Line count, complexity score, information density metrics
Layer 2: Cognitive Architecture
Reasoning Model: What thinking pattern does it enforce? (Discovery ‚Üí Analysis ‚Üí Synthesis / Plan ‚Üí Execute ‚Üí Validate / etc.)
Decision Points: Where are the choice nodes? What triggers each branch?
Cognitive Dependencies: What knowledge must exist before this can be applied?
Mental Model Alignment: How does it map to developer thinking patterns?
"Why Before How" Chain: Trace the intention ‚Üí action flow
Layer 3: Integration Topology
Workflow Position: Which of the 6 phases (Bootstrap / Client Discovery / PRD / Tasks / Process / Audit / Retrospective)?
Rule Dependencies: What other rules must load before/after this?
Protocol Orchestration: What protocols does it trigger or depend on?
Script Bindings: Which automation scripts hook into its checkpoints?
Quality Gates: What validation layers does it enforce?
Evidence Flow: What evidence does it require as input? What does it produce as output?
Layer 4: Execution Mechanics
Trigger Conditions: What keywords, contexts, or states activate this?
Activation Sequence: What happens step-by-step when triggered?
Checkpoints & Gates: Where are the validation/approval points?
Human-in-the-Loop: Where does it require manual intervention?
Automation Hooks: Where do scripts take over from reasoning?
Fallback Protocols: What happens on failure or ambiguity?
Layer 5: System Impact Analysis
Scope of Influence: What parts of the system does it affect?
Modification Ripple: If changed, what else breaks?
Conflict Detection: Does it overlap or contradict other rules?
Performance Impact: How expensive is it to execute?
Security/Safety Implications: What risks does it mitigate or introduce?
Technical Debt: Does it introduce complexity or reduce it?
Layer 6: Quality & Completeness Assessment
Coverage Score: How well does it address its stated purpose?
Gap Analysis: What scenarios are NOT handled?
Ambiguity Detection: Are there unclear or contradictory directives?
Evidence Sufficiency: Does it define success criteria clearly?
Maintainability: Is it easy to update and extend?
Discoverability: Can it be found via tags/triggers/scope?
Layer 7: Evolutionary Context
Design Intent: WHY was this created? What problem does it solve?
System Evolution: How does it fit into the system's growth trajectory?
Future Extensibility: How easy is it to add new capabilities?
Migration Path: If deprecated, what replaces it?
Historical Debt: Does it carry legacy constraints?
Details
Input Methods:
Direct file path: /analyze-meta <path>
File content paste: /analyze-meta [content]
Current context: /analyze-meta @current-rule
Batch analysis: /analyze-meta @all-master-rules
Output Format (Comprehensive Report):

# Meta-Instruction Analysis Report
## File: [filename]

### üèóÔ∏è LAYER 1: STRUCTURAL ANATOMY
- **Type**: [Master Rule / Protocol / etc.]
- **Metadata**: 
  - Tags: [list]
  - Triggers: [list]
  - Scope: [value]
  - Always Apply: [yes/no]
- **Directives**: [count of STRICT vs GUIDELINE]
- **Sections**: [major sections with line ranges]
- **Complexity**: [score/10 with reasoning]

### üß† LAYER 2: COGNITIVE ARCHITECTURE
- **Reasoning Model**: [description]
- **Decision Points**: [list with conditions]
- **Cognitive Dependencies**: [what must be known first]
- **Mental Model**: [how it maps to developer thinking]
- **Why‚ÜíHow Chain**: [trace the reasoning flow]

### üîó LAYER 3: INTEGRATION TOPOLOGY
- **Workflow Phase**: [which of 6 phases]
- **Rule Dependencies**: 
  - Must load before: [list]
  - Must load after: [list]
- **Protocol Triggers**: [which protocols it calls]
- **Script Bindings**: [automation hooks]
- **Quality Gates**: [validation checkpoints]
- **Evidence Flow**:
  - Input: [what it requires]
  - Output: [what it produces]

### ‚öôÔ∏è LAYER 4: EXECUTION MECHANICS
- **Trigger Conditions**: [when it activates]
- **Activation Sequence**: [step-by-step flow]
- **Checkpoints**: [validation points]
- **Human Gates**: [where manual approval needed]
- **Automation Hooks**: [script takeover points]
- **Fallback**: [error handling]

### üåä LAYER 5: SYSTEM IMPACT ANALYSIS
- **Scope of Influence**: [affected components]
- **Modification Ripple**: [impact if changed]
- **Conflicts**: [any detected overlaps]
- **Performance**: [execution cost]
- **Security/Safety**: [risk analysis]
- **Technical Debt**: [complexity assessment]

### ‚úÖ LAYER 6: QUALITY & COMPLETENESS
- **Coverage Score**: [X/10 with gaps identified]
- **Gap Analysis**: [unhandled scenarios]
- **Ambiguities**: [unclear directives]
- **Evidence Sufficiency**: [success criteria clarity]
- **Maintainability**: [ease of update]
- **Discoverability**: [searchability score]

### üîÆ LAYER 7: EVOLUTIONARY CONTEXT
- **Design Intent**: [original purpose]
- **System Evolution**: [role in growth]
- **Extensibility**: [ease of adding features]
- **Migration Path**: [future alternatives]
- **Historical Debt**: [legacy constraints]

---

## üìä EXECUTIVE SUMMARY
[3-5 sentence synthesis of the most critical insights]

## üö® CRITICAL FINDINGS
[Any conflicts, gaps, or high-priority issues]

## üí° RECOMMENDATIONS
[Actionable suggestions for improvement]

dvanced Capabilities:
Comparative Analysis: Compare 2+ meta-instructions side-by-side
Dependency Graph: Visualize rule/protocol relationships
Impact Simulation: "What if this rule is removed/modified?"
Conflict Resolution: Detect and suggest fixes for overlapping rules
Optimization Suggestions: How to make it more efficient/clear
Template Generation: Create similar rules based on this pattern
Expected Outcome
You will have a Meta-Instruction Intelligence System that:
Deeply understands any rule/protocol you show it
Explains in multiple layers from structure to philosophy
Identifies hidden connections and dependencies
Detects quality issues and gaps
Provides actionable insights for improvement
Maps to the larger system architecture
Predicts impact of changes
Teaches you the meta-architecture principles
This will enable you to:
Audit system integrity comprehensively
Onboard new contributors faster
Refactor confidently without breaking things
Design new rules aligned with existing patterns
Debug workflow issues by understanding root causes
Evolve the system strategically
